

### 1. 函数内部修改全局变量


不能重新赋值

```
x = 2

def func():
    x = x + 2
    return x
```

可以引用, 或修改内部元素

```
x = []

def func():
    x.append(1)
    return x
```

### 2. == 和 is

== 是判断变量所指的值是否相等

is 是判断是否是同一个变量


```
# 变量赋值在 [-5, 256] 的中时, 两个变量指向同一个内存空间

a = 1
b = 1
print(a == b) # True

a = 257
b = 257
print(a == b) # False
```

### 3. 浅拷贝 & 深拷贝

赋值：原对象的引用，没有创建新的对象

浅拷贝：创建新的对象，浅拷贝的元素是子对象的引用，所以如果子对象是可变的，改变其也会影响拷贝后的对象，存在副作用。

```
a = [1, [1, 2]]
b = a

a[1].append(3)

print(b) # [1, [1, 2, 3]]
```

```
a = [1, (1, 2)]
b = a

a[1] += (3)

print(b) # [1, (1, 2)]
```

深拷贝：深拷贝会递归的拷贝原对象的每一个子对象，拷贝后的对象和原对象互不相干

![image](06843D4BED924BA49A19F3709A0E55F9)


### 4. Python 函数参数传递的方式

不是"值传递", 也不是"引用传递", 是"对象的引用传递" (即图中的形参A)

![image](29B80CFE7360476DB54B8C560C360C2F)



### 5. 关于装饰器

`优势`：将通用的处理单独抽离出来，保留核心处理逻辑，降低耦合度提高程序重用性

`特性`:

- 装饰器中 @ 称之为语法糖, @my_decorator 相当于 greet = my_decorator(greet) 语法

- 被装饰的函数, 其元信息会变成装饰器的元信息, 但是可以使用内置装饰器 @functools.wrap 恢复至原本的元信息

- 使用 wrapper(*args **kwargs) 接受被装饰函数的原有参数

- 可以使用自定义参数的装饰器, 例如: @logger(level="INFO") 那样的装饰器需要定义至三层 (第一层接收其自定义参数, 第二层接收被装饰的函数引用, 第三层接收被装饰的函数的参数)

- 类也可以作为装饰器被定义, 实现其 __call__ 方法即可

- 装饰器嵌套时执行顺序, 从里到外


`一般的使用场景`:

身份认证

日志记录

输入参数检测

缓存

`示例`：

```
def logger(func):
    @fuctools.wraps(func)
    def wrapper(*args, **kwargs):
        r = func(args, kwargs)
        return r
    return wrapper
```
